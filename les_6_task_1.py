"""
Задача 1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых
трех уроков.
Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:

● выбрать хорошую задачу, которую имеет смысл оценивать по памяти (укажите какую задачу вы взяли в комментарии);

● написать 3 варианта кода (один у вас уже есть);

● проанализировать 3 варианта и выбрать оптимальный;

● результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;

● написать общий вывод: какой из трёх вариантов лучше и почему.

Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной, а проявили
творчество, фантазию и создали универсальный код для замера памяти.
"""

"""
Для анализа возьмем задачу №1 из урока 3:
В диапазоне натуральных чисел от 2 до 99 определить, сколько из них кратны каждому из чисел
в диапазоне от 2 до 9.
"""

"""
Версия интерпретатора Python - 3.8, разрядность - 64
ОС 64-х разрядная
"""

import sys


# напишем универсальную функцию для суммирования размера памяти

def sum_memory(*objects):
    sum_ = 0
    for obj in objects:
        sum_ += sys.getsizeof(obj)
    return sum_


# вариант 1 (исходный)

numbers = [i for i in range(2, 100)]
digits = [i for i in range(2, 10)]

result = dict()
for i in digits:
    result[i] = 0

for n in numbers:
    for x in digits:
        if n % x == 0:
            result[x] += 1

# print(result)

for key, value in result.items():
    print(f'{value} чисел в массиве кратны {key}')

print(sum_memory(numbers, digits, result, i, n, x, key, value))  # 1524

# вариант 2

numbers = tuple([i for i in range(2, 100)])

result = [0 for _ in range(8)]

for n in numbers:
    for x in range(2, 10):
        if n % x == 0:
            result[x - 2] += 1

# print(result)

for i, value in enumerate(result, start=2):
    print(f'{value} чисел в массиве кратны {i}')

print(sum_memory(numbers, result, i, n, x, value))  # 1056

# вариант 3

result = [0 for _ in range(8)]

for n in range(2, 100):
    for x in range(2, 10):
        if n % x == 0:
            result[x - 2] += 1

# print(result)

for i in range(2, 10):
    print(f'{result[i - 2]} чисел в массиве кратны {i}')

print(sum_memory(result, i, n, x))  # 204

# print(sys.getsizeof(range(1_000_000_000)))   48

"""
Выводы: наиболее оптимальный вариант №3 (занимает всего 204 байта), так как в нем использовался всего один список
для хранения результата, а числа, необходимые для решения задачи были взяты из диапазона range, данный объект
занимает 48 байт вне зависисмости от его величины. Списки без острой необходимости лучше не применять.
Словари занимают большой объем памяти, но при этом более эффективны с точки зрения быстродействия.

Как окончательный вывод - при написании кода необходимо минимизировать количество используемых
переменных, списков и словарей, при этом исходить из задачи и возможностей вычислительной машины (искать золотую
середину между быстродействием и затратами ОЗУ).
"""
